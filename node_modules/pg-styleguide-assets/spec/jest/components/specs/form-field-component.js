require(path(pathMap.components, "form/form-field"));
jest.autoMockOff();

describe("form field component", function() {
  var  rendered, container;

  beforeEach(function() {
    PG.Components.InputField = genMockComponent();
    rendered = utils.renderIntoDocument(
      <PG.Components.FormField label="Test">
        <PG.Components.InputField />
        <PG.Components.InputField />
      </PG.Components.FormField >

    );
    container = rendered.getDOMNode();
  });

  it("renders label correctly", function() {
    rendered.setProps({ label: "Text"});
    var findings = container.querySelectorAll(".form-field label");
    expect(findings.length).toBe(1);
    expect(findings[0].textContent).toBe("Text");
  });

  it("renders anchor correctly", function() {
    rendered.setProps({ anchorText: "Text", anchorHref: "url"});
    var findings = container.querySelectorAll(".form-field-link");
    expect(findings.length).toBe(1);
    expect(findings[0].textContent).toBe("Text");
  });

  it("renders label and input next to each other when inlineLabel prop set to true", function() {
    rendered.setProps({ inlineLabel: true });
    expect(container.className.split(" ").indexOf("inline-label")).toBeGreaterThan(-1);
  });

  it("doesn't render errors by default", function() {
    var findings = container.querySelectorAll(".field-error-message");
    expect(findings.length).toBe(0);
  });

  it("renders an error when errorMessage prop set", function() {
    rendered.setProps({ errorMessage: "Error!" });
    var findings = container.querySelectorAll(".field-error-message");
    expect(findings.length).toBe(1);
    expect(findings[0].textContent).toBe("Error!");
  });

  it("applies 'error' class to the container and label when errorMessage prop set", function() {
    rendered.setProps({ errorMessage: "Error!" });
    var findings = container.querySelectorAll("label.error");
    expect(findings.length).toBe(1);
    expect(container.className.split(" ").indexOf("error")).toBeGreaterThan(-1);
  });

  it("applies 'success' class to the label when errorMessage is empty and all input fields have value", function() {
    var findings = container.querySelectorAll("label.success");
    expect(findings.length).toBe(0);

    rendered.setProps({ children: [
      <PG.Components.InputField value="Some Text" />
    ]});

    var findings = container.querySelectorAll("label.success");
    expect(findings.length).toBe(1);
  });

  it("doesn't rendered errors when state.focused is set to true", function() {
    rendered.setProps({ errorMessage: "Error!" });
    rendered.setState({ focused: true });
    var findings = container.querySelectorAll(".field-error-message");
    expect(findings.length).toBe(0);
  });

  it("sets state.focused to true when any of child inputs was focused", function() {
    expect(rendered.state.focused).toBe(false);
    rendered.handleInputFocus(<PG.Components.InputField />);
    expect(rendered.state.focused).toBe(true);
  });

  it("sets state.focused to false when any of child inputs was blured", function() {
    rendered.setState({ focused: true});
    rendered.handleInputBlur(<PG.Components.InputField />);
    expect(rendered.state.focused).toBe(false);
  });

  describe("child components", function() {
    it("renders correct number of child components", function() {
      var inputs = utils.scryRenderedComponentsWithType(rendered, PG.Components.InputField);
      expect(inputs.length).toBe(2);
    });

    it("sets 'inline' prop to false for a single input field", function() {
      rendered.setProps({ children: [
        <PG.Components.InputField />
      ]});
      var inputs = utils.scryRenderedComponentsWithType(rendered, PG.Components.InputField);
      expect(inputs.length).toBe(1);
      expect(inputs[0].props.inline).toBe(false);
    });

    it("sets 'inline' prop to true for multiple input fields", function() {
      rendered.setProps({ children: [
        <PG.Components.InputField />,
        <PG.Components.InputField />
      ]});
      var inputs = utils.scryRenderedComponentsWithType(rendered, PG.Components.InputField);
      expect(inputs.length).toBe(2);
      expect(inputs[0].props.inline).toBe(true);
      expect(inputs[1].props.inline).toBe(true);
    });

    it("sets focusHandler prop", function() {
      var inputs = utils.scryRenderedComponentsWithType(rendered, PG.Components.InputField);
      expect(typeof inputs[0].props.focusHandler).toEqual("function");
    });

    it("sets blurHandler prop", function() {
      var inputs = utils.scryRenderedComponentsWithType(rendered, PG.Components.InputField);
      expect(typeof inputs[0].props.blurHandler).toBe("function");
    });
  });
});